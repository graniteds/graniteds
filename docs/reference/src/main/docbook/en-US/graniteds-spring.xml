<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
   
<chapter id="graniteds.spring">
	<title>Integration with Spring</title>
	<para>
	The <ulink url="http://www.springframework.org">Spring framework</ulink> is one of the most popular Java enterprise frameworks. It integrates on a common 
	platform all the necessary services for building enterprise applications: persistence, transactions, security... 
	</para>
    
    <para condition="flex">
    GraniteDS provides out-of-the-box integration with Spring 2.5+ and 3.0+ via either the <literal>RemoteObject</literal> API or the Tide API 
    to remotely call Spring services, and fully supports serialization of JPA entities from and to your Flex application, taking care of lazily loaded associations. 
    The support for JPA entity beans is covered in the section <link linkend="remoting.jpa">JPA and lazy initialization</link>, so this section will only 
    describe how to call Spring beans from a Flex application. GraniteDS also fully supports Acegi Security / Spring Security 2.x / Spring Security 3.x.
    </para>
    <para condition="java">
    GraniteDS provides out-of-the-box integration with Spring 2.5+ and 3.0+ via either the <literal>RemoteService</literal> API or the Tide API 
    to remotely call Spring services, and fully supports serialization of JPA entities from and to your Java client application, taking care of lazily loaded associations. 
    The support for JPA entity beans is covered in the section <link linkend="remoting.jpa">JPA and lazy initialization</link>, so this section will only 
    describe how to call Spring beans from a Java application. GraniteDS also fully supports Acegi Security / Spring Security 2.x / Spring Security 3.x.
    </para>
    
    <para>
    The support for Spring is included in the library <literal>granite-spring.jar</literal>, so you always have to include this library in either
    <literal>WEB-INF/lib</literal> or <literal>lib</literal> for an ear packaging.
    </para>
    
    <para>
    Note that to provide a more native experience for Spring developers, the Spring support in GraniteDS can be configured directly in the Spring configuration
    files (<literal>applicationContext.xml</literal>). Most features of GraniteDS can be configured this way, and it is still possible to fall back to the 
    default GraniteDS configuration files <literal>services-config.xml</literal> and <literal>granite-config.xml</literal> for unsupported features. 
    </para>
    
    <para condition="flex">
    For a basic example with GraniteDS and Spring working together, 
    have a look to the <literal>graniteds_spring</literal> example project in the <literal>examples</literal> folder of the GraniteDS distribution 
    <literal>graniteds-***.zip</literal> and import it as a new Eclipse project.
    </para>
    
    <section id="spring.mvcsetup">
        <title>Spring MVC setup</title>
        <para>
        It is perfectly possible to use the default setup for the GraniteDS servlet in <literal>web.xml</literal>, but the recommended way when using Spring 
        is to configure a Spring MVC dispatcher servlet and handle incoming AMF requests. This will in particular allow configuring GraniteDS in the Spring
        application context. You also need to setup the Spring request and application listeners but this is standard Spring configuration.
        Note that this works only for the remoting servlet, but you still have to configure the Gravity servlet in the default way 
        because the Spring MVC dispatcher servlets cannot support non blocking I/O.
        </para>
        <programlisting role="XML">
<![CDATA[<!-- Path to Spring config file -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>
        /WEB-INF/conf/application-context.xml
    </param-value>
</context-param>

<!-- Spring application listener -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!-- Spring listener for web-scopes (request, session) -->
<listener>
    <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>
</listener>

<!-- Spring MVC dispatcher servlet for AMF remoting requests -->
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/graniteamf/*</url-pattern>
</servlet-mapping>]]>  
        </programlisting>
        <para>
        You also have to add an empty file <literal>WEB-INF/dispatcher-servlet.xml</literal>:
        </para>
        <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xsi:schemaLocation="
       http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd>       
</beans>]]>
        </programlisting>
	</section>
	
	<section id="spring.remoteobject">
	   <title condition="flex">Using the RemoteObject API</title>
	   <title condition="java">Using the RemoteService API</title>
        <para condition="flex">
        The Flex-side usage of the <literal>RemoteObject</literal> API is completely independent of the server technology, so everything described in 
        the <link linkend="remoting.remoteobject">Remoting</link> chapter applies for Spring beans. This section will only describe the particular configuration
        required in various use cases of Spring services.
        </para>
        <para condition="java">
        The client-side usage of the <literal>RemoteService</literal> API is completely independent of the server technology, so everything described in 
        the <link linkend="remoting.remoteservice">Remoting</link> chapter applies for Spring beans. This section will only describe the particular configuration
        required in various use cases of Spring services.
        </para>
	   
        <section id="spring.roexample" condition="flex">
            <title>Basic remoting example</title>
            <para>
            All remoting examples from the <link linkend="remoting.remoteobject">Remoting</link> chapter apply for Spring beans, here is a basic example
            with an annotated Spring service:
            </para>
            <programlisting role="JAVA">
<![CDATA[public interface HelloService {

    public String hello(String name);
}

@Service("helloService")
@RemoteDestination(id="helloService", source="helloService")
public class HelloServiceImpl implement HelloService {

    public String hello(String name) {
        return "Hello " + name;
    }
}]]>
            </programlisting>
            
            <programlisting role="XML">
<![CDATA[<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml">

    <mx:Script>
        import mx.rpc.events.ResultEvent;
        import mx.rpc.events.FaultEvent;
        import mx.controls.Alert;
        
        public function resultHandler(event:ResultEvent):void {
            // Display received message
            outputMessage.text = event.result as String;
        }                       
        
        public function faultHandler(event:FaultEvent):void {
            // Show error alert
            Alert.show(event.fault.faultString);               
        }
    </mx:Script>
    
    <!-- Connect to a service destination.--> 
    <mx:RemoteObject id="helloService" 
        destination="helloService"
        source="helloService"
        result="handleResult(event);"
        fault="handleFault(event);"/>
    
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
    
    <!-- Call the Spring service, use the text in a TextInput control as input data.--> 
    <mx:Button click="helloService.hello(inputName.text)"/>
    
    <!-- Display results data in the user interface. --> 
    <mx:Label id="outputMessage"/>
</mx:Application>]]>
            </programlisting>
            
            <para>
            The main thing to note is the use of the <literal>source</literal> property in both the <literal>RemoteObject</literal> definition
            and in the <literal>@RemoteDestination</literal> annotation that should match the name of the Spring bean (here in <literal>@Service</literal>).
            </para>
        </section>
	   
        <section id="spring.rsexample" condition="java">
            <title>Basic remoting example</title>
            <para>
            All remoting examples from the <link linkend="remoting.remoteobject">Remoting</link> chapter apply for Spring beans, here is a basic example
            with an annotated Spring service:
            </para>
            <programlisting role="JAVA">
<![CDATA[public interface HelloService {

    public String hello(String name);
}

@Service("helloService")
@RemoteDestination(id="helloService", source="helloService")
public class HelloServiceImpl implement HelloService {

    public String hello(String name) {
        return "Hello " + name;
    }
}]]>
            </programlisting>
            
            <programlisting role="JAVA">
<![CDATA[AMFRemotingChannel channel = new AMFRemotingChannel(transport, "graniteamf", 
	new URI("http://localhost:8080/helloworld/graniteamf/amf.txt"));
RemoteService srv = new RemoteService(channel, "helloService");

srv.newInvocation("hello", "Barack").setTimeToLive(5, TimeUnit.SECONDS)
	.addListener(new ResultFaultIssuesResponseListener() {
    
	@Override
	public void onResult(ResultEvent event) {
		System.out.println("Result: " + event.getResult());
	}

	@Override
	public void onFault(FaultEvent event) {
		System.err.println("Fault: " + event.toString());
	}

	@Override
	public void onIssue(IssueEvent event) {
		System.err.println("Issue: " + event.toString());
	}
}).invoke();
]]>
            </programlisting>
        </section>
        
	   <section id="spring.romvcconfig">
	       <title>Configuration with a MVC setup</title>
	        <para>
	        Besides configuring the dispatcher servlet (see <link linkend="spring.mvcsetup">here</link>), configuring GraniteDS in the Spring context 
	        just requires adding the <literal>graniteds</literal> namespace and adding a <literal>server-filter</literal> element:
	        </para>
	        <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:graniteds="http://www.graniteds.org/config"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
        http://www.graniteds.org/config http://www.graniteds.org/public/dtd/3.0.0/granite-config-3.0.xsd">

    ...
    
    <graniteds:server-filter url-pattern="/*"/>

</beans>]]>        
            </programlisting>
            
            <para>
            The actual url that will be listened to by the AMF processor is the combination of the <literal>url-pattern</literal> in the Spring context 
            and the <literal>servlet-mapping</literal> of the dispatcher servlet in <literal>web.xml</literal>.
            The configuration described here maps GraniteDS on <literal>/graniteamf/*</literal> and is suitable in almost all cases.
            </para>
            
            <para>
            When necessary, this configuration can be overriden or completed by the default configuration in <literal>services-config.xml</literal> described 
            in the <link linkend="spring.rostdconfig">next section</link>.
            In this case, the implicit configuration created by the MVC setup contains the following elements :
            <itemizedlist>
                <listitem><para>
				a remoting service named <literal>granite-service</literal>
				</para></listitem>
				<listitem><para>
				a remoting service factory named <literal>spring-factory</literal>
				</para></listitem>
				<listitem><para>
				a remoting channel named <literal>graniteamf</literal>
				</para></listitem>
            </itemizedlist>
            The MVC setup automatically enables component scanning, so you can just annotate your Spring services with <literal>@RemoteDestination</literal> 
            and put an empty <literal>META-INF/services-config.properties</literal> file in your services jar or folder to tell GraniteDS where to look for services. 
            See last paragraph <link linkend="spring.roscan">Automatic Configuration of Destinations</link>.
            </para>
            
            <para>
            Alternatively you can also declare the remote destinations manually in the Spring context:
            </para>
            <programlisting role="XML">            
<![CDATA[<graniteds:remote-destination id="personService" source="personService"/>]]> 
            </programlisting>
            <para>
            You can also specify a secure destination by adding the list of roles required to access the destination:
            </para>
            <programlisting role="XML">            
<![CDATA[<graniteds:remote-destination id="personService" source="personService">
    <graniteds:roles>
        <graniteds:role>ROLE_ADMIN</graniteds:role>
    </graniteds:roles>
</graniteds:remote-destination>]]> 
            </programlisting>
            
            <para>
            The support for Spring Security is automatically enabled when Spring Security is installed in the application and the version of Spring Security is automatically detected. 
            However if you have configured more than one <literal>AuthenticationManager</literal>s, it will be necessary to instruct GraniteDS which one should be used 
            for authentication by adding the following line to your Spring configuration :
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:security-service authentication-manager="myAuthenticationManager"/>]]>
            </programlisting>
            <para>
            With this declaration you can also provide various configuration elements for the Spring 3 security service implementation : 
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:security-service 
		authentication-manager="myAuthenticationManager"
    	allow-anonymous-access="true"
    	authentication-trust-resolver="com.myapp.MyAuthenticationTrustResolver"
    	session-authentication-strategy="com.myapp.MySessionAuthenticationStrategy"
        security-context-repository="com.myapp.MySecurityContextRepository"
        security-interceptor="com.myapp.MySecurityInterceptor"
        password-encoder="com.myapp.MyPasswordEncoder"
/>]]>
            </programlisting>
            
            <para condition="flex">
            Finally remember that as there is no <literal>services-config.xml</literal>, you will have to manually initialize the endpoints 
            for your client <literal>RemoteObject</literal>s (also see <link linkend="remoting.manualremoteobject">here</link>) :
            </para>
            
            <programlisting role="AS3" condition="flex">
<![CDATA[srv.destination = "personService";
srv.source = "personService";
srv.channelSet = new ChannelSet();
srv.channelSet.addChannel(new AMFChannel("graniteamf", 
    "http://{server.name}:{server.port}/{context.root}/graniteamf/amf"));]]>
            </programlisting>
	   </section>
       
       <section id="spring.rostdconfig">
           <title>Default configuration</title>
            <para>
            Configuring remoting for Spring services simply requires using the <literal>org.granite.spring.SpringServiceFactory</literal> service factory in 
            <literal>services-config.xml</literal>:
            </para>
            <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<services-config>
    <services>
        <service
            id="granite-service"
            class="flex.messaging.services.RemotingService"
            messageTypes="flex.messaging.messages.RemotingMessage">
            <destination id="testBean">
                <channels>
                    <channel ref="graniteamf"/>
                </channels>
                <properties>
                    <factory>springFactory</factory>
                    <source>springBean</source>
                </properties>
                <security>
                    <security-constraint>
                        <auth-method>Custom</auth-method>
                        <roles>
                            <role>ROLE_USER</role>
                            <role>ROLE_ADMIN</role>
                        </roles>
                    </security-constraint>
                </security>
            </destination>
        </service>
    </services>

    <factories>
        <factory id="springFactory" class="org.granite.spring.SpringServiceFactory" />
    </factories>

    <channels>
        <channel-definition id="graniteamf" class="mx.messaging.channels.AMFChannel">
            <endpoint
                uri="http://{server.name}:{server.port}/{context.root}/graniteamf/amf"
                class="flex.messaging.endpoints.AMFEndpoint"/>
        </channel-definition>
    </channels>

</services-config>]]>
            </programlisting>
            
            <para>
            The only thing that should be noted for Spring destinations is that you have to specify a <literal>source</literal> property specifying the name
            of the remote Spring bean.
            </para>
       </section>
       
       <section id="spring.roscan">
            <title>Automatic configuration of destinations</title>
            <para>
            It is possible to instruct GraniteDS to automatically search for Spring destinations in the classpath by:
            <itemizedlist>
                <listitem><para>
                Enabling scanning in <literal>granite-config.xml</literal> (scanning is always enabled with a MVC setup).
                <programlisting>
&lt;granite-config scan="true"/&gt;
                </programlisting>
                </para></listitem>
                <listitem><para>
                Adding an empty <literal>META-INF/services-config.properties</literal> marker file in all jars containing Spring services
                </para></listitem>
                <listitem><para>
                Annotating the Spring service (or preferably its interface) with <literal>org.granite.messaging.service.annotations.RemoteDestination</literal>
                </para></listitem>
            </itemizedlist>
            </para>
            <programlisting role="JAVA">
@RemoteDestination(id="personService", source="personService", securityRoles={"user","admin"})
public interface PersonService {
}

@Service("personService")
public class PersonServiceBean implements PersonService {
  ...
}
            </programlisting>
            <para>
			The annotation supports the following attributes:
			<itemizedlist>
			<listitem><para>
            <literal>id</literal> is mandatory and is the name of the destination as used from Flex
            </para></listitem>
            <listitem><para>
            <literal>source</literal> is mandatory and should be the name of the Spring bean
            </para></listitem>
            <listitem><para>
            <literal>service</literal> is optional when there is only one service for <literal>RemotingMessage</literal> defined in <literal>services-config.xml</literal>. 
            Otherwise this should be the name of the service.
            </para></listitem>
            <listitem><para>
            <literal>channel</literal> is optional if there is only one channel defined in <literal>services-config.xml</literal>. 
            Otherwise this should be the id of the target channel.
            </para></listitem>
            <listitem><para>
            <literal>channels</literal> may be used instead of <literal>channel</literal> to define a failover channel.
            </para></listitem>
            <listitem><para>
            <literal>factory</literal> is optional if there is only one factory in <literal>services-config.xml</literal>. Otherwise this should be the factory id.
            </para></listitem>
            <listitem><para>
            <literal>securityRoles</literal> is an array of role names for securing the destination.
            </para></listitem>
			</itemizedlist>
			Using scanning allows simplifying your <literal>services-config.xml</literal> file, however it is recommended to use the MVC setup, so you don't even need one !
            </para>
       </section>
       
       <section id="spring.rosecurity">
           <title>Integration with Spring Security</title>
           <para>
           When not using the Spring MVC setup, you have to manually configure the integration of Spring Security in <literal>granite-config.xml</literal>.
           Depending on the version of Spring Security you are using, you can use one of the 3 available security services:
           </para>
           <para>
           Spring Security 3.x
           </para>
           <programlisting role="XML">
<![CDATA[<granite-config>
   ...
   <!--
    ! Use Spring based security service.
    !-->
    <security type="org.granite.spring.security.SpringSecurity3Service"/>

</granite-config>]]>
           </programlisting>
           <para>
           Spring Security 2.x
           </para>
           <programlisting role="XML">
<![CDATA[<granite-config>
   ...
   <!--
    ! Use Spring based security service.
    !-->
    <security type="org.granite.messaging.service.security.SpringSecurityService"/>

</granite-config>]]>
           </programlisting>
           <para>
           Acegi Security
           </para>
           <programlisting role="XML">
<![CDATA[<granite-config>
   ...
   <!--
    ! Use Spring based security service.
    !-->
    <security type="org.granite.messaging.service.security.AcegiSecurityService"/>

</granite-config>]]>
           </programlisting>
           
           <para>
           You may then secure your GraniteDS destinations as shown earlier. Please refer to <ulink url="http://www.springframework.org/">Acegi</ulink> 
           or <ulink url="http://static.springframework.org/spring-security/site/">Spring Security</ulink> documentation for specific configuration details.
           </para>
           
           <para>
           Note however that there are two main ways of securing the GraniteDS AMF endpoint:
           <itemizedlist>
                <listitem><para>
                Apply the Spring Security Web filter on the dispatcher servlet. This is the most secure and can be necessary if you share the same web 
                application between a rich client and an HTML client or if you want to use a HTML login form to protect access to the swf resource, but note that 
                as the request credentials are encoded in the AMF request and decoded by the servlet, the request will have to be authenticated as anonymous between 
                the Spring Security filter and the AMF service processor. That means that you have to enable the anonymous support in Spring Security, and that other 
                Web filters will not have access to the authenticated user.
                </para></listitem>
                <listitem><para>
                Let GraniteDS handle security and simply configure a secure remoting destination. This is the recommended way if your application only has a rich client.
                </para></listitem>
           </itemizedlist> 
           </para>
       </section>
	</section>
    
    <section id="spring.tide">
       <title>Using the Tide API</title>
        <para>
        Most of what is described in the <link linkend="remoting.tideremoting">Tide Remoting</link> section applies for Spring, however GraniteDS also provides
        an improved integration with Spring services.
        </para>
       
       <section id="spring.tidemvcconfig">
           <title>Configuration with a MVC setup</title>
           <para>
           This is by far the easiest way to use Tide with Spring, it just consists in declaring the GraniteDS flex filter in the Spring context:
           </para>
           <programlisting role="XML">
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:graniteds="http://www.graniteds.org/config"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
        http://www.graniteds.org/config http://www.graniteds.org/public/dtd/2.3.0/granite-config-2.3.xsd">

        ...
    
    <graniteds:server-filter url-pattern="/*" tide="true"/>
</beans>]]>
           </programlisting>
           
           <para>
           The <literal>server-filter</literal> declaration will setup an AMF processor for the specified url pattern, and the <literal>tide</literal> attribute 
           specifies that you want a Tide-enabled service factory. Note that the actual url that will be listened to by GraniteDS is the combination of this 
           <literal>url-pattern</literal> with the <literal>servlet-mapping</literal> defined in <literal>web.xml</literal> for the dispatcher servlet.
           </para>
           
           <para>
           Other configurations can be done with <literal>server-filter</literal>:
            <itemizedlist>
                <listitem><para>
                <literal>tide-annotations</literal> is equivalent to <literal>tide-component annotated-with=""</literal> in <literal>granite-config.xml</literal>. 
                It allows to define the list of annotation names that enable remote access to Spring beans. <literal>@RemoteDestination</literal> is always
                declared by default, but you can use any other one if you don't want a compilation dependency on the GraniteDS libraries.
                </para></listitem>
                <listitem><para>
                <literal>tide-roles</literal> allows to define a list of security roles that are required to access the Tide remote destination. 
                In general it is not necessary to define this destination-wide security and only rely on Spring security for fine-grained access to individual beans.
                </para></listitem>
                <listitem><para>
                <literal>security-service</literal> allows to specify the security service implementation.
                </para></listitem>
                <listitem><para>
                <literal>exception-converters</literal> allows to define a list of server-side exception converters. 
                It's the equivalent to <literal>exception-converters</literal> in <literal>granite-config.xml</literal>.
                </para></listitem>
                <listitem><para>
                <literal>amf3-message-interceptor</literal> allows to define a message interceptor that will be called before and after the processing of each incoming message. 
                You have to define the bean name of an existing bean implementing <literal>AMFMessageInterceptor</literal>.
                </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            Additional elements can also be configured in the Spring beans file:
            <itemizedlist>
                <listitem><para>
                <literal>tide-identity</literal> allows to declare the identity bean. 
                When using Spring Security ACL you can define here the necessary attributes <literal>acl-service</literal>, <literal>sid-retrieval-strategy</literal> 
                and <literal>object-identity-retrieval-strategy</literal>.
                </para></listitem>
                <listitem><para>
                <literal>tide-persistence</literal> allows to declare the persistence implementation for your application. 
                It is not necessary when you have only one Spring <literal>transactionManager</literal>, otherwise just specify the name of 
                the transaction manager to use. Tide/Spring will automatically determine the kind of transaction management it should use (JTA, JPA or Hibernate API).
                </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            Note that in addition to these manual elements, any Spring bean implementing one of the GraniteDS interfaces <literal>SecurityService</literal>,
            <literal>ExceptionConverter</literal>, <literal>AMFMessageInterceptor</literal> or <literal>TidePersistenceManager</literal> will be automatically
            picked up and registered in the GraniteDS configuration.
            </para>
       </section>
       
        <section id="spring.tidestdconfig">
          <title>Default configuration</title>
            <para>
            If you don't use the MVC setup, you will have to use the standard GraniteDS configuration files instead of the Spring context, and setup these 
            elements manually. You can safely skip this section if you chose the recommended MVC setup.
            <itemizedlist>
              <listitem><para>
              You can define in the <literal>tide-annotations</literal> section of <literal>granite-config.xml</literal> the conditions 
              used to enable remote access to Spring destinations (for example all beans annotated with a particular annotation). 
              </para></listitem>
              <listitem><para>
              You have to configure the specific Tide/Spring <literal>org.granite.tide.spring.SpringServiceFactory</literal> service factory 
              in <literal>services-config.xml</literal>.
              </para></listitem>
              <listitem><para>
              You have to configure a unique Tide/Spring destination named <literal>spring</literal> in <literal>services-config.xml</literal>
              </para></listitem>
              <listitem condition="flex"><para>
              You have to retrieve the Tide context in Flex with <literal>Spring.getInstance().getSpringContext()</literal> 
              instead of <literal>Tide.getInstance().getContext()</literal>.
              </para></listitem>
              <listitem condition="java"><para>
              You must use the destination named <literal>spring</literal> when creating the <literal>ServerSession</literal>.
              </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            Here is a default configuration suitable for most cases:
            </para>
            
            <programlisting role="XML">
<![CDATA[<granite-config scan="true">
    ...
    
    <tide-components>
        <tide-component annotated-with="org.granite.messaging.service.annotations.RemoteDestination"/>
    </tide-components>
    
</granite-config>]]>    
            </programlisting>
            
            <programlisting role="XML">
<![CDATA[<services-config>

    <services>
        <service id="granite-service"
            class="flex.messaging.services.RemotingService"
            messageTypes="flex.messaging.messages.RemotingMessage">
            <!--
             ! Use "tideSpringFactory" and "my-graniteamf" for "ejb" destination (see below).
             ! The destination must be "spring" when using Tide with default configuration.
             !-->
            <destination id="spring">
                <channels>
                    <channel ref="my-graniteamf"/>
                </channels>
                <properties>
                    <factory>tideSpringFactory</factory>
                </properties>
            </destination>
        </service>
    </services>

    <!--
     ! Declare tideSpringFactory service factory.
     !-->
    <factories>
        <factory id="tideSpringFactory" class="org.granite.tide.spring.SpringServiceFactory"/>
    </factories>

    <!--
     ! Declare my-graniteamf channel.
     !-->
    <channels>
        <channel-definition id="graniteamf" class="mx.messaging.channels.AMFChannel">
            <endpoint
                uri="http://{server.name}:{server.port}/{context.root}/graniteamf/amf"
                class="flex.messaging.endpoints.AMFEndpoint"/>
        </channel-definition>
    </channels>

</services-config>]]>    
            </programlisting>
            
            <para>
            The destination named <literal>spring</literal> will be the one and only destination required for all Spring destinations. 
            </para>
            
            <para>
            You should also define the correct Spring security service in <literal>granite-config.xml</literal>, see <link linkend="spring.rosecurity">here</link>
            for details.
            </para>
            
            <para>
            You can use the property <literal>entity-manager-factory-bean-name</literal> to specify an <literal>EntityManagerFactory</literal> bean
            that will be used for transparent remote lazy loading of collections.
            </para>
            
            <para>
            Here is an example with a Spring JPA/Hibernate configuration: 
            </para>
            
            <programlisting role="XML">
<![CDATA[<persistence-unit name="spring-pu">
    ...
</persistence-unit>]]>
            </programlisting>
            
            <programlisting role="XML">
<![CDATA[<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName">
        <value>org.hsqldb.jdbcDriver</value>
    </property>
    <property name="url">
        <value>jdbc:hsqldb:mem:springds</value>
    </property>
    <property name="username">
        <value>sa</value>
    </property>
    <property name="password">
        <value></value>
    </property>
</bean>

<bean id="entityManagerFactory"
    class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="dataSource" ref="dataSource" />
    <property name="persistenceUnitName" value="spring-pu" />
    <property name="jpaVendorAdapter">
        <bean
            class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
            <property name="showSql" value="false" />
            <property name="generateDdl" value="true" /> 
            <property name="databasePlatform" value="org.hibernate.dialect.HSQLDialect" />
        </bean>
    </property>      
</bean>

<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
    <property name="entityManagerFactory" ref="entityManagerFactory" />
    <property name="dataSource" ref="dataSource" />
</bean>]]>
            </programlisting>
            
            <para>
            If you use a plain Hibernate session instead of JPA, you cannot use <literal>entity-manager-factory-bean-name</literal>, you have to configure
            a specific Tide persistence manager in the Spring context (assuming the bean name of the Hibernate session factory is <literal>sessionFactory</literal>):
            </para>
            
            <programlisting role="XML">
<![CDATA[<!-- All this AOP stuff is to ensure the Tide persistence manager will be transactional -->
  <aop:config>
    <aop:pointcut id="tidePersistenceManagerMethods" 
        expression="execution(* org.granite.tide.ITidePersistenceManager.*(..))"/>
    <aop:advisor advice-ref="tidePersistenceManagerMethodsTxAdvice" 
        pointcut-ref="tidePersistenceManagerMethods"/>
  </aop:config>

  <tx:advice id="tidePersistenceManagerMethodsTxAdvice" 
    transaction-manager="transactionManager">
    <tx:attributes>
      <tx:method name="*" propagation="REQUIRED" read-only="true"/>
    </tx:attributes>
  </tx:advice>

  <bean id="tidePersistenceManager"
    class="org.granite.tide.hibernate.HibernateSessionManager" scope="request">
    <constructor-arg>
      <ref bean="sessionFactory"/>
    </constructor-arg>
  </bean>]]>            
            </programlisting>
       </section>
       
       <section id="spring.tideremotingdi.flex" condition="flex">
            <title>Basic remoting with dependency injection</title>
            <para>
            When using Spring, the only difference on the client is that you have to use the <literal>Spring</literal> singleton. Here is a simple example of 
            remoting with an injected client proxy for a Spring service:
            </para>
                   
            <programlisting role="XML" condition="flex">
<![CDATA[<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
    creationComplete="Spring.getInstance().initApplication()">
    <mx:Script>
        import org.granite.tide.spring.Spring;
        import org.granite.tide.events.TideResultEvent;
        import org.granite.tide.events.TideFaultEvent;
        
        [In]
        public var helloService:Component;
        
        private function hello(name:String):void {
            helloService.hello(name, resultHandler, faultHandler);
        }
        
        private function resultHandler(event:TideResultEvent):void {
            outputMessage.text = event.result as String;
        }                       
        
        private function faultHandler(event:TideFaultEvent):void {
            // Handle fault
        }
    </mx:Script>
    
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
    
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="hello(inputName.text)"/>
    
    <!-- Result message. --> 
    <mx:Label id="outputMessage"/>
</mx:Application>]]>
            </programlisting>
            
            <para>
            This is almost identical to the standard Tide API described in the <link linkend="remoting.tideremoting">Tide remoting</link> section, and all other
            methods apply for Spring. 
            </para>
       </section>
            
       <section id="spring.tideremotingdi.java" condition="java">
            <title>Basic remoting with dependency injection</title>
            <para>
            When using Spring, the only difference on the client is that you must use the <literal>spring</literal> destination to build the <literal>ServerSession</literal>. 
            Here is a simple example of remoting with an injected client proxy for a Spring service:
            </para>            
	       	
	        <programlisting role="JAVA">
<![CDATA[public class HelloController {

	@Inject @Qualifier("helloService")
	private Component helloService;
	
    public void hello(String to) {
    	// Asynchronous call using handlers
    	helloService.call("hello", to, new TideResponder<String>() {
    		@Override
    		public void result(TideResultEvent<String> result) {
    			System.out.println("Async result: " + result.getResult());
    		}
    		
    		@Override
    		public void fault(TideFaultEvent fault) {
    			System.err.println("Fault: " + fault.getFault());
    		}
    	};
    }
    
    public String helloSync(String to) {	
    	// Synchronous wait of Future result
    	Future<String> futureResult = helloService.call("hello", to);
    	String result = futureResult.get();
    	System.out.println("Sync result: " + result);
    	return result;
    }
}]]>
	        </programlisting>
            
            <para>
            This is almost identical to the standard Tide API described in the <link linkend="remoting.tideremoting">Tide remoting</link> section, and all other
            methods apply for Spring. 
            </para>
       </section>
            
       <section id="spring.tideremotingtypesafe.flex" condition="flex">
            <title>Typesafe remoting with dependency injection</title>
            <para>
            You can benefit from the capability of the Gas3 code generator (see <link linkend="graniteds.gas3">here</link>) to generate a strongly typed 
            ActionScript 3 client proxy from the Spring interface when it is annotated with <literal>@RemoteDestination</literal>.
            In this case, you can inject a typesafe reference to your service and get better compile time error checking and auto completion in your IDE:
            </para>
            
            <programlisting role="XML">
<![CDATA[<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
    creationComplete="Spring.getInstance().initApplication()">
    <mx:Script>
        import org.granite.tide.spring.Spring;
        import org.granite.tide.events.TideResultEvent;
        import org.granite.tide.events.TideFaultEvent;
        import com.myapp.service.HelloService;
        
        [In]
        public var helloService:HelloService;
        
        private function hello(name:String):void {
            helloService.hello(name, resultHandler, faultHandler);
        }
        ...
    </mx:Script>
    
    ...
</mx:Application>]]>
            </programlisting>
            
            <para>
            It is possible to benefit from even more type safety by using the annotation <literal>[Inject]</literal> instead of <literal>In</literal>.
            When using this annotation, the full class name is used to find the target bean in the Spring context instead of the bean name.
            </para>
            
            <programlisting role="XML">
<![CDATA[<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
    creationComplete="Spring.getInstance().initApplication()">
    <mx:Script>
        import org.granite.tide.spring.Spring;
        import org.granite.tide.events.TideResultEvent;
        import org.granite.tide.events.TideFaultEvent;
        import com.myapp.service.HelloService;
        
        [Inject]
        public var myService:HelloService;
        
        private function hello(name:String):void {
            myService.hello(name, resultHandler, faultHandler);
        }
        ...
    </mx:Script>
    
    ...
</mx:Application>]]>
            </programlisting>
        </section>
	        
	   <section id="spring.tideremotingtypesafe.java" condition="java">
            <title>Typesafe remoting with dependency injection</title>
            <para>
            You can benefit from the capability of the Gfx code generator (see <link linkend="graniteds.gfx">here</link>) to generate a strongly typed 
            Java client proxy from the Spring interface when it is annotated with <literal>@RemoteDestination</literal>.
            In this case, you can inject a typesafe reference to your service and get better compile time error checking and auto completion in your IDE:
            </para>
	        
	        <programlisting role="JAVA">
<![CDATA[public class HelloController {

	@Inject @Qualifier("helloService")
	private HelloService helloService;
	
   	// Asynchronous call using handlers
   	helloService.hello("Barack", new TideResponder<String>() {
   		@Override
   		public void result(TideResultEvent<String> result) {
   			System.out.println("Async result: " + result.getResult());
   		}
   		
   		@Override
   		public void fault(TideFaultEvent fault) {
   			System.err.println("Fault: " + fault.getFault());
   		}
   	};
   	
   	// Synchronous wait of Future result
   	Future<String> futureResult = helloService.hello("Barack");
   	String result = futureResult.get();
   	System.out.println("Sync result: " + result);
}]]>
	        </programlisting>
	        
	        <para>
	        Note that as there is only one instance of <literal>HelloService</literal>, you may also omit the <literal>Qualifier</literal> annotation and use 
	        typesafe injection with <literal>@Inject</literal> only.
	        </para>
        </section>
        
        <section id="spring.tidesecurity.flex" condition="flex">
            <title>Integration with Spring Security</title>
            <para>
            GraniteDS provides a client-side component named <literal>identity</literal> that ensures the integration between the client <literal>Channel</literal>
            credentials and the server-side container security. It additionally includes an easy-to-use API to define runtime authorization checks on the UI. 
            </para>
            <para>
            Enabling support for the client <literal>identity</literal> component requires to configure the corresponding server-side component in the Spring context:            
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:tide-identity/>]]>
            </programlisting>
            <para>
            If you want to integrate with Spring Security ACL authorizations, you will have to specify the name of the ACL service and optionally the
            Object ID retrieval strategy and SID retrieval strategy (see details on Spring Security ACL  
            <ulink url="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/domain-acls.html">here</ulink>):
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:tide-identity acl-service="myAclService"
     object-identity-retrieval-strategy="myObjectIdentityRetrievalStrategory" 
     sid-retrieval-strategy="mySIDRetrievalStrategy"/>]]>
            </programlisting>
            
            <para>
            The Flex <literal>identity</literal> component for Spring (of class <literal>org.granite.tide.spring.Identity</literal>) predictably provides two methods 
            <literal>login()</literal> and <literal>logout()</literal> that can be used as any Tide remote call:
            </para>
            <programlisting role="AS3">
private var tideContext:Context = Spring.getInstance().getSpringContext();

public function login(username:String, password:String):void {
    tideContext.identity.login(username, password, loginResult, loginFault);
}

private function loginResult(event:TideResultEvent):void {
    Alert.show(event.context.identity.loggedIn);
}

private function loginFault(event:TideFaultEvent):void {
    Alert.show(event.fault);
}

public function logout():void {
    tideContext.identity.logout();
}
            </programlisting>
            <para>
            Or with dependency injection:
            </para>
            <programlisting role="AS3">
[Inject]
public var identity:Identity;
            
public function login(username:String, password:String):void {
    identity.login(username, password, loginResult, loginFault);
}

private function loginResult(event:TideResultEvent):void {
    Alert.show(event.context.identity.loggedIn);
}

private function loginFault(event:TideFaultEvent):void {
    Alert.show(event.fault);
}

public function logout():void {
    identity.logout();
}
            </programlisting>
            
            <para>
            The <literal>identity</literal> component also exposes the bindable property <literal>loggedIn</literal> that represents the current authentication state.
            As it is bindable, it can be used to choose between different views, for example to switch between a login form and the application view with a Flex
            <literal>ViewStack</literal> component:
            </para>
            
            <programlisting role="XML">
<![CDATA[<mx:ViewStack id="main" selectedIndex="{identity.loggedIn ? 1 : 0}">
    <views:LoginView id="loginView"/>
    <views:MainView id="mainView"/>
</mx:ViewStack>]]>
            </programlisting>
            
            <para>
            Finally the <literal>identity</literal> component is integrated with server-side role-based security and can be used to get information or show/hide UI
            depending on the user access rights. It provides methods similar to the Spring Security jsp tags <literal>sec:ifAllGranted</literal>, 
            <literal>sec:ifAnyGranted</literal>, <literal>sec:ifNotGranted</literal> and <literal>sec:hasPermission</literal>.
            </para>
            <programlisting role="XML">
<![CDATA[<mx:Button id="deleteCategoryButton" 
    label="Delete Category"
    enabled="{identity.ifAllGranted('ROLE_ADMIN')}"
    click="productService.deleteCategory(category)"/>
    
<mx:Button id="deleteProductButton" label="Delete Product"
    enabled="{productGrid.selectedItem}"
    visible="{identity.hasPermission(productGrid.selectedItem, '8,16')}"
    click="productService.deleteProduct(productGrid.selectedItem)"/>
]]>
            </programlisting>
            <para>
            With these declaration, the button labeled <emphasis>Delete Category</emphasis> will be enabled only if the user has the role <literal>ROLE_ADMIN</literal>
            and the button <emphasis>Delete Product</emphasis> only if the user has the ACL permissions DELETE (code 8) or ADMINISTER (code 16) for the selected product.
            Another possibility is to completely hide the button with the properties <literal>visible</literal> and <literal>includeInLayout</literal>, or any other
            property relevant for the display of the UI component.
            </para>
            <para>
            The three methods are:
            <itemizedlist>
                <listitem><para>
                <literal>ifAllGranted</literal>/<literal>ifAnyGranted</literal>: the user should have the specified role
                </para></listitem>
                <listitem><para>
                <literal>ifNotGranted</literal>: the user should not have the specified role
                </para></listitem>
                <listitem><para>
                <literal>hasPermission</literal>: the user should have the specified permission for the specified entity 
                </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            This can also be used as any remote class with result and fault handlers: 
            </para>
            <programlisting role="AS3">
 public function checkRole(role:String):void {
    identity.ifAllGranted(role, checkRoleResult, checkRoleFault);
 }
 
 private function checkRoleResult(event:TideResultEvent, role:String):void {
    if (role == 'ROLE_ADMIN') {
        if (event.result)
            trace("User has admin role");
        else
            trace("User does not have admin role");
    }
 }
            </programlisting>
            
            <para>
            You can notice that the result and fault handlers have a second argument so you can use the same handler for many access check calls.            
            </para>
            
            <warning><para>
            <literal>identity.ifAllGranted()</literal> will issue a remote call when it is called the first time, thus its return value cannot be used reliably
            to determine if the use has the required role. It will always return <literal>false</literal> until the remote call result is received.
            </para></warning>
            
            <para>
            It is important to note that <literal>identity</literal> caches the user access rights so only the first call to <literal>ifAllGranted()</literal> 
            will be remote. If the user rights are changed on the server, or if you want to enforce security more than once per user session, you can clear 
            the security cache manually with <literal>identity.clearSecurityCache()</literal>, for example periodically with a <literal>Timer</literal>.
            </para>
        </section>
    
        <section id="spring.tidesecurity.java" condition="java">
            <title>Integration with Spring Security</title>
            <para>
            GraniteDS provides a client-side JavaFX component named <literal>identity</literal> which ensures the integration between the client <literal>Channel</literal> 
            credentials and the server-side container security. 
            It additionally includes an easy-to-use API to define runtime authorization checks on the UI. 
            </para>
            <para>
            Enabling support for the client <literal>identity</literal> component requires to configure the corresponding server-side component in the Spring context:            
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:tide-identity/>]]>
            </programlisting>
            <para>
            If you want to integrate with Spring Security ACL authorizations, you will have to specify the name of the ACL service and optionally the
            Object ID retrieval strategy and SID retrieval strategy (see details on Spring Security ACL  
            <ulink url="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/domain-acls.html">here</ulink>):
            </para>
            <programlisting role="XML">
<![CDATA[<graniteds:tide-identity acl-service="myAclService"
     object-identity-retrieval-strategy="myObjectIdentityRetrievalStrategory" 
     sid-retrieval-strategy="mySIDRetrievalStrategy"/>]]>
            </programlisting>
            
            <para>
            The client <literal>Identity</literal> component for Spring (of class <literal>org.granite.client.tide.javafx.spring.Identity</literal>) predictably provides two methods 
            <literal>login()</literal> and <literal>logout()</literal> that can be used as any Tide remote call:
            </para>
            <programlisting role="JAVA">
<![CDATA[@Inject
private Identity identity;

public function login(String username, String password) {
	identity.login(username, password, new TideResponder<String>() {
		@Override
		public void result(TideResultEvent<String> event) {
			System.out.println("Logged in as " + event.getResult());
		}
		
		@Override
		public void fault(TideFaultEvent event) {
			System.out.println("Could not log in");
		}
	});
}

public function logout() {
	identity.logout(new TideResponder<Void>() {
		@Override
		public void result(TideResultEvent<Void> event) {
			System.out.println("Logged out");
		}
		
		@Override
		public void fault(TideFaultEvent event) {
			System.out.println("Could not log out");
		}
	});
}]]>
            </programlisting>
            
            <para>
            The <literal>identity</literal> component also exposes the bindable property <literal>loggedIn</literal> that represents the current authentication state.
            As it is bindable, it can be used to choose between different views, for example to switch between a login form and the application:
            </para>
            
            <programlisting role="JAVA">
<![CDATA[
identity.loggedInProperty().addListener(new ChangeListener<Boolean>() {
	@Override
	public void changed(ObservableValue<? extends Boolean> property, Boolean oldValue, Boolean newValue) {
		if (newValue)
			showView("applicationView");
		else
			showView("loginForm");
    }
});]]>
            </programlisting>
            
            <para>
            Finally the <literal>identity</literal> component is integrated with server-side role-based security and can be used to get information or show/hide UI
            depending on the user access rights. It provides methods similar to the Spring Security jsp tags <literal>sec:ifAllGranted</literal>, 
            <literal>sec:ifAnyGranted</literal>, <literal>sec:ifNotGranted</literal> and <literal>sec:hasPermission</literal>.
            </para>
            <programlisting role="JAVA">
<![CDATA[Button deleteCategoryButton = new Button();
deleteCategoryButton.setText("Delete Category");
deleteCategoryButton.disableProperty().bind(Bindings.not(identity.ifAllGranted("ROLE_ADMIN")));

Button deleteProductButton = new Button();
deleteProductButton.setText("Delete Product");
deleteProductButton.visibleProperty().bind(identity.hasPermission(productTable.getSelectionModel().getSelectedItem(), "8,16"));]]>
            </programlisting>
            <para>
            With these declarations, the button labeled <emphasis>Delete Category</emphasis> will be enabled only if the user has the role <literal>ROLE_ADMIN</literal>
            and the button <emphasis>Delete Product</emphasis> visible only if the user has the ACL permissions DELETE (code 8) or ADMINISTER (code 16) for the selected product.
            Of course any other property can be bound to these observable elements.
            </para>
            <para>
            The available elements are:
            <itemizedlist>
                <listitem><para>
                <literal>ifAllGranted</literal>/<literal>ifAnyGranted</literal>: the user should have the specified role
                </para></listitem>
                <listitem><para>
                <literal>ifNotGranted</literal>: the user should not have the specified role
                </para></listitem>
                <listitem><para>
                <literal>hasPermission</literal>: the user should have the specified permission for the specified entity 
                </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            This can also be used as any remote class with result and fault handlers: 
            </para>
            <programlisting role="JAVA">
<![CDATA[
 public void checkRole(final String role) {
    identity.ifAllGranted(role).get(new TideResponder<Boolean>() {
    	@Override
 		public void result(TideResultEvent<Boolean> event) {
    		if (role.equals("ROLE_ADMIN")) {
        		if (event.getResult())
            		System.out.println("User has admin role");
        		else
            		System.out.println("User does not have admin role");
    		}
		}
		
		@Override
		public void fault(TideFaultEvent event) {
			System.err.println("Error getting role access for role " + role);
		}
    });
 }]]>
            </programlisting>
            
            <warning><para>
            <literal>identity.ifAllGranted()</literal> will issue a remote call when it is called the first time, thus its return value cannot be used reliably
            to determine if the use has the required role. It will always return <literal>false</literal> until the remote call result is received.
            </para></warning>
            
            <para>
            It is important to note that <literal>identity</literal> caches the user access rights so only the first call to <literal>ifAllGranted()</literal> 
            will be remote. If the user rights are changed on the server, or if you want to enforce security more than once per user session, you can clear 
            the security cache manually with <literal>identity.clearSecurityCache()</literal>, for example periodically with a <literal>Timer</literal>.
            </para>
        </section>
    </section>
    
    <section id="spring.messaging">
       <title>Messaging with Spring (Gravity)</title>
       <para>
       It is possible to configure the three kinds of Gravity topics directly in the Spring context instead of <literal>services-config.xml</literal>: 
       </para>
       <para>
       Simple Topic:
       </para>
       <programlisting role="XML">
<![CDATA[<graniteds:messaging-destination id="myTopic"/>]]>
       </programlisting>
       <para>
       This declaration supports the properties <literal>no-local</literal> and <literal>session-selector</literal> (see the <link linkend="messaging.configuration">
       Messaging Configuration section</link>).
       </para>
       <para>
       You can also define a secure destination by specifying a list of roles required to access the topic:
       </para>
       <programlisting role="XML">
<![CDATA[<graniteds:messaging-destination id="myTopic">
    <graniteds:roles>
        <graniteds:role>ROLE_ADMIN</graniteds:role>
    </graniteds:roles>
<graniteds:messaging-destination/>]]>
       </programlisting>
       
       <para>
       JMS Topic:
       </para>
       <programlisting role="XML">
<![CDATA[<graniteds:jms-messaging-destination id="myTopic"
    connection-factory="ConnectionFactory"
    destination-jndi-name="topic/MyTopic"
    transacted-sessions="true"
    acknowledge-mode="AUTO_ACKNOWLEDGE"/>]]>
       </programlisting>
       <para>
       This declaration supports all properties of the default JMS declaration in <literal>services-config.xml</literal> except for non local initial context
       environments (see the <link linkend="messaging.jms">JMS Integration</link> section).
       </para>
       
       <para>
       ActiveMQ Topic:
       </para>
       <programlisting role="XML">
<![CDATA[<graniteds:activemq-messaging-destination id="myTopic"
    connection-factory="ConnectionFactory"
    destination-jndi-name="topic/MyTopic"
    transacted-sessions="true"
    acknowledge-mode="AUTO_ACKNOWLEDGE"
    broker-url="vm://localhost"
    create-broker="true"
    wait-for-start="true"
    durable="true"
    file-store-root="/opt/activemq/data"/>]]>
       </programlisting>
       <para>
       This declaration supports all properties of the default ActiveMQ declaration in <literal>services-config.xml</literal> except for non local initial context
       environments (see the <link linkend="messaging.activemq">ActiveMQ Integration</link> section).
       </para>
       <para>
       Finally note that the <literal>Gravity</literal> singleton that is needed to push messages from the server (see <link linkend="messaging.servertoclient">here</link>)
       is available as a bean in the Spring context and can be autowired by type with <literal>@Inject</literal> or <literal>@Autowired</literal> :
       </para>
       <programlisting role="JAVA">
<![CDATA[@Inject
private Gravity gravity;]]>
       </programlisting>
    </section>
</chapter>
